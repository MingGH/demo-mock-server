<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>èµŒåšæ¨¡æ‹Ÿå™¨ - å•å…ƒæµ‹è¯•</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a2e; color: #fff; }
    .pass { color: #4ade80; }
    .fail { color: #ff6b6b; }
    .test-group { margin: 20px 0; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 8px; }
    .test-group h3 { margin-bottom: 10px; color: #feca57; }
    .test-result { padding: 5px 0; }
    .summary { margin-top: 20px; padding: 15px; border-radius: 8px; font-size: 1.2em; }
    .summary.all-pass { background: rgba(74,222,128,0.2); border: 1px solid #4ade80; }
    .summary.has-fail { background: rgba(255,107,107,0.2); border: 1px solid #ff6b6b; }
  </style>
</head>
<body>
  <h1>ğŸ§ª èµŒåšæ¨¡æ‹Ÿå™¨å•å…ƒæµ‹è¯•</h1>
  <div id="results"></div>
  <div id="summary"></div>

<script>
// ========== æ ¸å¿ƒé€»è¾‘ï¼ˆä»ä¸»æ–‡ä»¶æŠ½å–ï¼‰ ==========

/**
 * æ¨¡æ‹Ÿå•æ¬¡èµŒåš
 * @param {number} currentMoney - å½“å‰èµ„é‡‘
 * @param {number} bet - æŠ¼æ³¨é‡‘é¢
 * @param {number} rake - æŠ½æ°´æ¯”ä¾‹ (0-1)
 * @param {boolean} win - æ˜¯å¦èµ¢ï¼ˆç”¨äºæµ‹è¯•ï¼Œå®é™…ä½¿ç”¨æ—¶éšæœºï¼‰
 * @returns {number} èµŒåšåçš„èµ„é‡‘
 */
function simulateBet(currentMoney, bet, rake, win) {
  if (currentMoney < bet) {
    return currentMoney; // é’±ä¸å¤Ÿï¼Œä¸èƒ½èµŒ
  }
  
  if (win) {
    // èµ¢äº†ï¼šè·å¾— bet * (1 - rake)
    return currentMoney + bet * (1 - rake);
  } else {
    // è¾“äº†ï¼šå¤±å» bet
    return currentMoney - bet;
  }
}

/**
 * è®¡ç®—å•æ¬¡èµŒåšçš„æœŸæœ›å€¼
 * @param {number} bet - æŠ¼æ³¨é‡‘é¢
 * @param {number} rake - æŠ½æ°´æ¯”ä¾‹ (0-1)
 * @param {number} winProb - èµ¢çš„æ¦‚ç‡ (0-1)
 * @returns {number} æœŸæœ›å€¼
 */
function calculateExpectedValue(bet, rake, winProb = 0.5) {
  const winAmount = bet * (1 - rake);
  const loseAmount = bet;
  return winProb * winAmount - (1 - winProb) * loseAmount;
}

/**
 * æ¨¡æ‹Ÿå¤šè½®èµŒåš
 * @param {number} initialMoney - åˆå§‹èµ„é‡‘
 * @param {number} bet - æ¯å±€æŠ¼æ³¨
 * @param {number} rake - æŠ½æ°´æ¯”ä¾‹
 * @param {number} rounds - è½®æ•°
 * @param {function} randomFn - éšæœºå‡½æ•°ï¼Œè¿”å› true/false
 * @returns {object} { finalMoney, roundsPlayed, history }
 */
function simulateMultipleRounds(initialMoney, bet, rake, rounds, randomFn = () => Math.random() < 0.5) {
  let money = initialMoney;
  const history = [money];
  let roundsPlayed = 0;
  
  for (let i = 0; i < rounds; i++) {
    if (money < bet) break; // ç ´äº§
    
    const win = randomFn();
    money = simulateBet(money, bet, rake, win);
    history.push(money);
    roundsPlayed++;
  }
  
  return { finalMoney: money, roundsPlayed, history };
}

// ========== æµ‹è¯•æ¡†æ¶ ==========

let passCount = 0;
let failCount = 0;
const results = [];

function test(name, fn) {
  try {
    fn();
    passCount++;
    results.push({ name, pass: true });
  } catch (e) {
    failCount++;
    results.push({ name, pass: false, error: e.message });
  }
}

function assertEqual(actual, expected, message = '') {
  if (actual !== expected) {
    throw new Error(`${message} Expected ${expected}, got ${actual}`);
  }
}

function assertApprox(actual, expected, tolerance = 0.01, message = '') {
  if (Math.abs(actual - expected) > tolerance) {
    throw new Error(`${message} Expected ~${expected}, got ${actual}`);
  }
}

function assertTrue(condition, message = '') {
  if (!condition) {
    throw new Error(message || 'Expected true');
  }
}

// ========== æµ‹è¯•ç”¨ä¾‹ ==========

// æµ‹è¯•ç»„1ï¼šå•æ¬¡èµŒåšé€»è¾‘
test('èµ¢äº†åº”è¯¥è·å¾— bet*(1-rake)', () => {
  const result = simulateBet(1000, 100, 0.05, true);
  assertEqual(result, 1095, '1000 + 100*0.95 = 1095');
});

test('è¾“äº†åº”è¯¥å¤±å» bet', () => {
  const result = simulateBet(1000, 100, 0.05, false);
  assertEqual(result, 900, '1000 - 100 = 900');
});

test('é’±ä¸å¤Ÿæ—¶ä¸èƒ½èµŒ', () => {
  const result = simulateBet(50, 100, 0.05, true);
  assertEqual(result, 50, 'é’±ä¸å¤Ÿï¼Œåº”è¯¥ä¿æŒä¸å˜');
});

test('0%æŠ½æ°´æ—¶èµ¢äº†åº”è¯¥è·å¾—å…¨é¢', () => {
  const result = simulateBet(1000, 100, 0, true);
  assertEqual(result, 1100, 'æ— æŠ½æ°´æ—¶ 1000 + 100 = 1100');
});

test('10%æŠ½æ°´æ—¶èµ¢äº†åº”è¯¥è·å¾—90%', () => {
  const result = simulateBet(1000, 100, 0.1, true);
  assertEqual(result, 1090, '10%æŠ½æ°´æ—¶ 1000 + 90 = 1090');
});

// æµ‹è¯•ç»„2ï¼šæœŸæœ›å€¼è®¡ç®—
test('5%æŠ½æ°´æ—¶æœŸæœ›å€¼åº”è¯¥æ˜¯è´Ÿçš„', () => {
  const ev = calculateExpectedValue(100, 0.05, 0.5);
  assertApprox(ev, -2.5, 0.01, 'æœŸæœ›å€¼åº”è¯¥æ˜¯ -2.5');
});

test('0%æŠ½æ°´æ—¶æœŸæœ›å€¼åº”è¯¥æ˜¯0', () => {
  const ev = calculateExpectedValue(100, 0, 0.5);
  assertApprox(ev, 0, 0.01, 'å…¬å¹³æ¸¸æˆæœŸæœ›å€¼åº”è¯¥æ˜¯ 0');
});

test('10%æŠ½æ°´æ—¶æœŸæœ›å€¼åº”è¯¥æ˜¯-5', () => {
  const ev = calculateExpectedValue(100, 0.1, 0.5);
  assertApprox(ev, -5, 0.01, 'æœŸæœ›å€¼åº”è¯¥æ˜¯ -5');
});

test('æœŸæœ›å€¼å…¬å¼éªŒè¯ï¼šEV = 0.5*win - 0.5*lose', () => {
  // bet=100, rake=5%
  // win = 100 * 0.95 = 95
  // lose = 100
  // EV = 0.5 * 95 - 0.5 * 100 = 47.5 - 50 = -2.5
  const ev = calculateExpectedValue(100, 0.05, 0.5);
  const manual = 0.5 * 95 - 0.5 * 100;
  assertApprox(ev, manual, 0.01);
});

// æµ‹è¯•ç»„3ï¼šå¤šè½®æ¨¡æ‹Ÿ
test('å…¨èµ¢æ—¶èµ„é‡‘åº”è¯¥æŒç»­å¢é•¿', () => {
  const result = simulateMultipleRounds(1000, 100, 0.05, 10, () => true);
  assertEqual(result.roundsPlayed, 10, 'åº”è¯¥ç©æ»¡10è½®');
  assertTrue(result.finalMoney > 1000, 'å…¨èµ¢æ—¶èµ„é‡‘åº”è¯¥å¢é•¿');
  // æ¯è½®èµ¢ 95ï¼Œ10è½®èµ¢ 950
  assertEqual(result.finalMoney, 1950, '1000 + 10*95 = 1950');
});

test('å…¨è¾“æ—¶åº”è¯¥ç ´äº§', () => {
  const result = simulateMultipleRounds(1000, 100, 0.05, 20, () => false);
  assertEqual(result.roundsPlayed, 10, '1000/100=10è½®åç ´äº§');
  assertEqual(result.finalMoney, 0, 'åº”è¯¥è¾“å…‰');
});

test('ç ´äº§åä¸èƒ½ç»§ç»­èµŒ', () => {
  const result = simulateMultipleRounds(100, 100, 0.05, 10, () => false);
  assertEqual(result.roundsPlayed, 1, 'åªèƒ½ç©1è½®');
  assertEqual(result.finalMoney, 0, 'è¾“å…‰äº†');
});

test('å†å²è®°å½•é•¿åº¦æ­£ç¡®', () => {
  const result = simulateMultipleRounds(1000, 100, 0, 5, () => true);
  assertEqual(result.history.length, 6, 'åˆå§‹+5è½®=6ä¸ªè®°å½•');
  assertEqual(result.history[0], 1000, 'åˆå§‹èµ„é‡‘');
  assertEqual(result.history[5], 1500, 'æœ€ç»ˆèµ„é‡‘');
});

// æµ‹è¯•ç»„4ï¼šå¤§æ•°å®šå¾‹éªŒè¯
test('å¤§é‡æ¨¡æ‹Ÿåå¹³å‡æ”¶ç›Šåº”è¯¥æ¥è¿‘æœŸæœ›å€¼', () => {
  const trials = 10000;
  let totalProfit = 0;
  
  for (let i = 0; i < trials; i++) {
    const result = simulateMultipleRounds(10000, 100, 0.05, 1, () => Math.random() < 0.5);
    totalProfit += result.finalMoney - 10000;
  }
  
  const avgProfit = totalProfit / trials;
  const expectedEV = -2.5; // æ¯å±€æœŸæœ›äºæŸ
  
  // å…è®¸ä¸€å®šè¯¯å·®ï¼ˆç»Ÿè®¡æ³¢åŠ¨ï¼‰
  assertApprox(avgProfit, expectedEV, 1, `å¹³å‡æ”¶ç›Š ${avgProfit.toFixed(2)} åº”è¯¥æ¥è¿‘ ${expectedEV}`);
});

test('é•¿æœŸèµŒåšç ´äº§ç‡åº”è¯¥å¾ˆé«˜', () => {
  const trials = 1000;
  let bankruptCount = 0;
  
  for (let i = 0; i < trials; i++) {
    const result = simulateMultipleRounds(1000, 100, 0.05, 1000);
    if (result.finalMoney < 100) bankruptCount++;
  }
  
  const bankruptRate = bankruptCount / trials;
  assertTrue(bankruptRate > 0.8, `ç ´äº§ç‡ ${(bankruptRate*100).toFixed(1)}% åº”è¯¥å¤§äº 80%`);
});

// æµ‹è¯•ç»„5ï¼šè¾¹ç•Œæ¡ä»¶
test('æŠ¼æ³¨é‡‘é¢ç­‰äºæœ¬é‡‘æ—¶', () => {
  const result = simulateBet(100, 100, 0.05, true);
  assertEqual(result, 195, '100 + 95 = 195');
});

test('æŠ¼æ³¨é‡‘é¢ç­‰äºæœ¬é‡‘è¾“äº†', () => {
  const result = simulateBet(100, 100, 0.05, false);
  assertEqual(result, 0, '100 - 100 = 0');
});

test('æé«˜æŠ½æ°´(50%)æ—¶æœŸæœ›å€¼', () => {
  const ev = calculateExpectedValue(100, 0.5, 0.5);
  assertApprox(ev, -25, 0.01, '50%æŠ½æ°´æ—¶æœŸæœ›å€¼æ˜¯ -25');
});

// ========== è¾“å‡ºç»“æœ ==========

function renderResults() {
  const container = document.getElementById('results');
  
  // æŒ‰æµ‹è¯•ç»„åˆ†ç»„
  const groups = {
    'å•æ¬¡èµŒåšé€»è¾‘': results.filter(r => r.name.includes('èµ¢äº†') || r.name.includes('è¾“äº†') || r.name.includes('é’±ä¸å¤Ÿ') || r.name.includes('æŠ½æ°´æ—¶')),
    'æœŸæœ›å€¼è®¡ç®—': results.filter(r => r.name.includes('æœŸæœ›å€¼')),
    'å¤šè½®æ¨¡æ‹Ÿ': results.filter(r => r.name.includes('å…¨èµ¢') || r.name.includes('å…¨è¾“') || r.name.includes('ç ´äº§') || r.name.includes('å†å²')),
    'å¤§æ•°å®šå¾‹éªŒè¯': results.filter(r => r.name.includes('å¤§é‡') || r.name.includes('é•¿æœŸ')),
    'è¾¹ç•Œæ¡ä»¶': results.filter(r => r.name.includes('æŠ¼æ³¨é‡‘é¢') || r.name.includes('æé«˜'))
  };
  
  let html = '';
  for (const [groupName, tests] of Object.entries(groups)) {
    if (tests.length === 0) continue;
    html += `<div class="test-group"><h3>${groupName}</h3>`;
    for (const t of tests) {
      const icon = t.pass ? 'âœ…' : 'âŒ';
      const cls = t.pass ? 'pass' : 'fail';
      html += `<div class="test-result ${cls}">${icon} ${t.name}`;
      if (!t.pass) html += ` - ${t.error}`;
      html += `</div>`;
    }
    html += `</div>`;
  }
  
  container.innerHTML = html;
  
  // æ€»ç»“
  const summary = document.getElementById('summary');
  const allPass = failCount === 0;
  summary.className = `summary ${allPass ? 'all-pass' : 'has-fail'}`;
  summary.innerHTML = `
    <strong>${allPass ? 'ğŸ‰ å…¨éƒ¨é€šè¿‡ï¼' : 'âš ï¸ æœ‰æµ‹è¯•å¤±è´¥'}</strong><br>
    é€šè¿‡: ${passCount} | å¤±è´¥: ${failCount} | æ€»è®¡: ${passCount + failCount}
  `;
}

renderResults();
</script>
</body>
</html>
